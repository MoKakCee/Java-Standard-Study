# 연산자(Operator)

### 연산자와 피연산자

---

> **연산자(operator) : 연산을 수행하는 기호( +,-,*,/ 등) 
피연산자(operand) : 연산자의 작업대상 ( 변수, 상수, 리터럴 수식)**
> 
- 연산자는 피 연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.

### 연산자의 종류

---

| 단항 연산자  | —, ++ | 값 1만큼 증가 또는 감소 |
| :---: | :---: | :---: |
| 산술 연산자 | +, -, *, /, % | 사칙 연산 및 나머지 연산 |
| 산술대입 연산자 |  +=, -=, /=, */ | 연산 후 우변의 값을 좌변에 저장 |
| 비교 연산자 | ≥, >, <, ≤, ==, !=  | 크고 작음과 같고 다름을 비교 |
|  논리 연산자 | &&, ||, !, &, |, ^, ~ | AND와 OR으로 조건을 연결 |
| 대입연산자 | = | 우변의 값을 좌변에 저장 |
| 기타 | (type), ?:, instanceof | 타입캐스팅. 삼항연산, 클래스 비교 |

### 연산자 우선순위와 결합 규칙

---

> **연산자 우선순위 :** 식에 사용된 연산자가 둘 이상인 경우, 연산자 우선순위에 의해서 연산순서가 결정된다.
**연산 결합규칙 :** 같은 우선순위의 연산자들이 여러개 있는 경우 규칙을 가지고 처리하는 것을 결합 규칙이한다.
> 

```kotlin
1. 산술 > 비교 > 논리 > 대입. 대입은 항상 맨 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 항상 이상연산자보다 높다.
3. 단항 연ㅅ나자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이ㅏㄷ.
```

### 산술변환(usual arthmetic conversion)

---

> **이항 연산자는 두피연산자의 타입이 일치해야 연산이 가능하다. 
따라서, 피연산자의 타입이 다르다면 연산 전에 형변환 연산자를 통해 타입을 일치시켜야 한다.**
> 
- 두 피연산자에 리턴 타입 결정은 **항상 더 큰 타입으로 일치**시킨다.
    - 작은 타입으로 형 변환시 **값 손실이 발생할 가능성(오버플로우/값 유실)**이 있기 때문이다.
- `int → float` 같은 작은 타입에서 큰타입의 형변환시 타입 캐스팅을 생략해도 된다.

```java
int i = 10;
float f = 20.0f;

float result = f + (float)i; // 타입 캐스팅 생량 가능
```

- **2가지 산술 형변환 규칙**

```java
1. 두 피연산자의 타입을 같게 일치시킨다 (큰 타입으로)
 - long + int -> long + long -> long
 - float + int -> float + float -> float
 - double + float -> double + double -> double
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.
 - byte + short -> int + int -> int
 - char + short -> int + int -> int
```

### 증감연산자

---

> 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
감소 연사자(—) : 피연산자의 값을 1 감소시킨다.
> 
- 일반적으로 단항연산자는 **피연산자(operand)의 왼쪽에 위치하지만, 증감 연산자는 양쪽 모두 가능하다.** 이에 따라 값의 결과가 달라질 수 있다.

| 타입 | 설명 | 사용예 |
| :---: | :---: | :---: |
| 전위형(prefix) | 값이 참조되기전에 증가시킨다. | j = ++i; |
| 후위형(postfix) | 값이 참조된 후에 증가시킨다. | j = i++; |

```java
public void prefixOper(){
	 int i = 0;
   j = i++;
   // i == 1, j == 0
}

public void postfixOper(){
	 int i = 0;
   j = ++i;
   // i == 1, j == 1
}
```

### 부호 연산자

---

> **부호 연산자(’-’)는 피연산자의 부호를 반대로 변경한 결과를 반환한다.
피연산자의 음수면 양수, 양수면 음수가 연산의 결과가 된다.**
> 

```java
public static void main(String[] args){
	int i = 10;
  i = -i;
  // i == 10;
}
```

### 사칙 연산자

---

> **일반 사칙연산과 마찬가지로 *, / 연산자가 =, -연산자 보다 높은 우선순위로 처리된다.**
> 
- 피연산자가 **정수형인 경우 나누는 수로 0을 사용할 수 없다.**
    - 만일 0으로 나누면 컴파일은 정상적으로 되지만 **실행시 런타임 오류가 발생**한다.
- `int` 형보다 작은 타입의 연산에 경우 `int`형으로 자동 형변환이 이루어지기 때문에 반환값에 `int`형을 명시해주어야 한다

```java
public static void main(String[] args){
  byte a = 10;
  byte b = 30;
  byte c = (byte) (a + b);
}
```

- 위와 같은 연산을 실행할 경우 반환 값으로 `300`을 예상하지만 `44`가 반환된다.
    - `byte`의 경우 `-127 ~ 127` 만을 범위로 입력받기 때문이다.
- 이처럼 형변환시 값 손실에 대한 문제는 프로그래머가 처리해야한다.

### 나머지 연산자

---

> **나머지 연산자는 외쪽 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는연산자**
> 
- 나눗셈 처럼 0을 사용할 수 없다.
- 나머지 연산자는 주로 짝수, 홀수 또는 배수 검사등에서 주로 사용된다.

### 비교 연산자

---

> **대소비교 연산자 :** 두 피연산자의 값의 크기를 비교하는 연산자이다. 참조형과, boolean 타입에서는 사용할 수 없다.
**등가비교 연산자 :** 두 피연산자와 값이 같은 지 다른지 비교하는 연산자이다. 모든 자료형에서 사용할 수 있다.
> 
- 등가 비교 연산자의 경우 **기본형이면 값을, 참조형이면 객체의 주소값을 비교**한다.

```java
float f = 0.1f;  // 0.1000000000149001 .. 
double d = 0.1;  // 0.1000000000000001 .. 
// (f == d) == false;
```

- 위 예제처럼 실수간의 비교에서는 저장 값에 따라 비교가 정상처리가 안될 수 도 있다.
    - 2진수로 변환하는 과정에서 오차가 발생한다.

```java
String str = "ABC";
str.equals("ABC") // true
str.equalsIgnoreCase("abc") // true
```

- `String` 과 같은 `reference Type`에 경우 `==` 연산은 주소 값을 비교하는 연산이기때문에 값을 비교할경우 `equals` 메서드를 통해 비교한다.
    - `String` 과 같이 `java.lang` 패키지에 클래스의 경우 대부분 `equals`가 구현되어있다.
    - 그외의 직점 정의한 커스텀 클래스의 경우 프로그래머가 직접 `equals`를 구현해야한다.
- `String` 클래스의 `equalsIgnoreCase`의 경우 소문자를 구분하지 않고 값을 비교한다.

### 논리 연산자

---

> **|| (OR 결합) : 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.
&& (AND 결합) : 피연산자 양쪽 모두 true이어야 ture를 결과로 얻는다.**
> 

```java
public static void main(String[] args){
	int i = 0;
  if(i == 0 || i != 0)
    return;
}
```

- **자바에서는 논리 연산자 사용시 LAZY 연산을 지원한다.**
    - 위 과정을 살펴보면 `if`문 첫번째 비교가 `true` 이며, `OR` 연산이기 때문에 그 후 연산이 불필요해진다.
    - 자바은 불필요한 연산을 하지않기 위해 **해당 연산에 필요한 값이 충족된다면 뒤 연산을 처리하지않고 해당 성공 로직을 실행**한다.

### 비트 연산자

---

> **| (OR 연산자) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외는 0을 얻는다.
& (AND 연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다 그 외에는 0을 얻는다.
& (XOR 연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 떄문 0을 얻는다.
~ (비트 전환 연산) : 피 연산자를 2진수로 표현했을 때 0은 1로 1은 0으로 바꾼다.
<<, >> (쉬프트연산자) : 연산자를 통해 피연산자의 값을 2진수 단위로 이동 연산을 수행한다.**
> 

### 삼항 연산자

---

> **삼항 연산자 : 3개의 피연산자를 필요로하는 연산자이다. 
result = 조건식 ? 식1 : 식2 로 표현되며, 조건식이 true일 경우 식1을 false일 경우 식2를 반환**
> 
- 삼항 연산자는 식을 추가로 삼항 연산자로 표현 가능하다.

```java
public static void main(String[] args){
 int i = 0;
 boolean result = i == 0 ? : true : false;
}

private boolean operator(int i){
	int j = 0;
  return i == 0 ? (j == 0 ? true : false) : false;
}
```

### 대입 연산자

---

> **대입연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다.**
> 
- **lvalue와 rvalue :** 대입 연산자의 왼쪽 피연산자를 `lvalue`라고 하고 오른쪽 피연산자를 `rvalue`라고 한다.
    - `rvalue`는 변수뿐 아니라 식이나 상수 등이 모두 가능하지만, `lvalue`는 반드시 변수처럼 값을 변경할 수있는 것이어야한다.

```java
int i = 0;
final int CONST_VAR = 1;
CONST_VAR = i; // lvalue error
```