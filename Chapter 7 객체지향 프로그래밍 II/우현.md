# CHAPTER 7 객체지향프로그래밍Ⅱ

### 상속

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

- 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 좋음
- `extends` 키워드

```java
class Parent { }
class Child extends Parent {
	//...
}
```

### 부모클래스 - 자식클래스

- 부모클래스에 멤버변수, 메서드를 추가하면 자식클래스도 자동적으로 추가된다.
- 반대로 자식클래스에 멤버변수, 메서드를 추가하면 부모클래스에게는 아무런 영향도 없다.
- 그렇기에 자식클래스는 부모클래스보다 같거나 많은 멤버를 갖는다.
- extends의 뜻은 확장이다.

**정리하면**

1. 자식 클래스는 부모 클래스의 모든 멤버를 상속받는다. (단, 생성자와 초기화 블럭은 상속되지 않는다.)
2. 자식 클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다.
3. 자식클래스의 인스턴스를 생성하면 부모클래스의 멤버도 함께 생성되기 때문에 따로 부모클래스의 인스턴스를 생성하지 않고도 부모클래스의 멤버들을 사용할 수 있다.

### 클래스 간의 관계 - 포함관계

상속이외에도 클래스를 재사용하는 또 다른 방법이 있는데, 그것은 클래스 간에 `포함`관계를 맺어 주는 것이다. 

클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
class Point {
	int x;
	int y;
}
```

```java
class Circle {
	Point c = new Point(); //포함관계
	int r;
}
```

### 클래스 간의 관계 결정하기

클래스를 작성할때 언제 상속관계를 맺고, 언제 포함관계를 맺을까?

**상속관계:** ‘~은 ~이다. (is-a)’

**포함관계:** ‘~은 ~을 가지고 있다. (has-a)’

ex) sportsCar는 Car다. → 상속

Deck은 Card를 가지고 있다 → 포함

**단일상속**

자바에서는 다중상속이 불가능

### Object클래스 - 모든 클래스의 부모

Object클래스는 모든 클래스 상속계층도의 최상위에 있는 부모클래스이다.

다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

다른 클래스로부터 상속받더라도 상속계층도를 따라 올라가면 결국 Object클래스로부터 상속받는다.

그래서 자바의 모든 클래스들은 Object클래스에 정의된 멤버들을 사용할 수 있다.

그동안 toString()이나 equals(Object 0)와 같은 메서드를 따로 정의하지 않고도 사용할 수 있었던 이유이다.

### 오버라이딩

부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버리이딩이라 한다.

상속받은 메서드를 그냥 사용해도 되지만, 자식 클래스에 맞게 변경해서 사용하는 경우가 많다.

### 오버라이딩 조건

1. 메서드의 선언부(메서드 이름, 매개변수, 반환타입)이 부모의 것과 완전히 일치해야 한다.

다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경 가능.

1. 접근 제어자는 부모 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
- private < (default) < protected < public
1. 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

### 오버로딩과 오버라이딩

**오버로딩**: 기존에 없는 새로운 메서드를 정의하는 것

**오버라이딩**: 상속받은 메서드의 내용을 변경하는 것

### 참조변수 super

super는 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.멤버변수와 지역변수의 이름이 같을때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버를 구별할때 super를 사용한다.

super키워드를 사용해서 부모클래스의 멤버를 지칭할 수 있다. 

**super() - 조상의 생성자**

this()처럼 super()도 생성자다.

this()는 같은 클래스의 다른 생성자를 호출하는데 사용, super()는 부모의 생성자를 호출하는데 사용

상속 관계에서 각 클래스의 멤버변수 초기화 할때는 해당 클래스의 생성자를 통해 초기화 하는게 좋은 방법이다.

```java
class Point {
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point {
	int z;

	Point3D(int x, int y, int z) {
		//부모클래스의 멤버를 자식이 직접 초기화는 별로 좋지 않은 방법
		//this.x = x;
		//this.y = y;

		super(x, y);  //부모클래스의 생성자를 통한 초기화를 하자
		this.z=z;  //자신의 멤버 초기화
	}
}
```

### 패키지

같은 이름의 클래스라도 패키지가 다르면 다른 클래스로 취급.

패키지명은 소문자로 하는게 원칙.

패키지에 속하지 않은 클래스들은 모두 `이름 없는 패키지` 에 속하게 된다.

### import문

소스코드에서 사용되는 클래스이름에서 패키지명을 생략할 수 있게 해준다.

### static import문

static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

### 제어자

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여

**접근 제어자:** public, protected, default, private

**그 외:** static, final, abstract, native, transient, synchronized, volatile, strictfp

### static - 클래스의, 공톡적인

static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

### final - 마지막의, 변경될 수 없는

‘마지막의’ 또는 ‘변경될 수 없는’의 의미로 거의 모든 대상에 사용될 수 있다.

변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

final클래스의 대표적인 예는 String과 Math이다.

### abstract - 추상의, 미완성의

메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용.

그리고 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.

abstract가 사용될 수 있는 곳 - 클래스, 메서드

```java
abstract class AbstractTest {  //추상 클래스(추상 메서드를 포함한 클래스)
	abstract void move();        //추상 메서드(구현부가 없는 메서드)
}
```

추상 클래스는 아직 완성되지 않은 메서드가 존재하는 ‘미완성 설계도’이므로 인스턴스를 생성할 수 없다.

### 접근 제어자(access modifier)

접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자

- private: 같은 클래스 내에서만 접근이 가능하다.
- default: 같은 패키지 내에서만 접근이 가능하다. (아무러 접근 제어자를 지정하지 않았을때)
- protected: 같은 패키지 내에서, 그리고 다른 패키지의 자식클래스에서 접근이 가능하다.
- public: 접근 제한이 전혀 없다.

### 캡슐화와 접근 제어자

클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다. 데이터의 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요. 이것이 객체지향개념의 캡슐화에 해당

즉 접근 제어자를 사용하는 이유는

1. 외부로부터 데이터를 보호하기 위해
2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해

보통 멤버변수의 값을 읽는 메서드의 이름을 ‘get멤버변수이름’으로 하고, 멤버변수의 값을 변경하는 메서드의 이름을 ‘set멤버변수이름’으로 한다.

### 다형성

다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.

무슨 말이냐면, 부모클래스의 타입의 참조변수로 자식클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

```java
class Tv {
	boolean power;
	int channel;

	void power() { power = !power}
	void channelUp() { ++channel; }
	void channelDown() { --channel; }
}

class CaptionTv extends Tv {
	String text;
	void caption() {...}
}

CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```

참조변수 c를 이용해서 모든 멤버를 사용할 수 있지만 참조변수 t는 Tv의 멤버들만 사용할 수 있다.

```java
CaptionTv c = new Tv(); //에러
```

부모클래스는 자식클래스를 참조할 수 있지만, 반대로 자식클래스의 참조변수로 부모클래스의 인스턴스를 참조할 수 없다.

### 참조변수의 형변환

기본형 변수처럼 참조변수도 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스 사이에서만 가능

따라서 모든 클래스의 조상인 Object클래스 타입으로 형변환이 가능하다.

### instanceof 연산자

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용.

```java
void doWork(Car c) {
	if (c instanceof FireEngine) {     // 1. 형변환이 가능한지 확인
			FireEngine fe = (FireEngine)c; // 2. 형변환
			fe.water();
			...
}
```

부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있기 때문에, 참조변수의 타입과 인스턴스의 타입이 항상 일치하지는 않는다.

부모타입의 참조변수로는 실제 인스턴스의 멤버들을 모두 사용할 수 없기 때문에, 실제 인스턴스와 같은 타입의 참조변수로 형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있다.

### 매개변수의 다형성

참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.

```java
class Product {...}
class Tv extends Product {...}
class Computer extends Product {...}

class Buyer {
	void buy(Product p) {  //매개변수를 부모타입으로 설정하여 모든 자식타입의 참조변수를 전달가능
		...	
	}
}
```

### 여러 종류의 객체를 배열로 다루기

```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

Vector: 동적으로 크기가 관리되는 객체배열

### 추상 클래스(abstract class)

추상 클래스는 미완성 설계도로 비유할 수 있다. (추상 메서드만 가지고 있음)

그렇기에 추상 클래스로는 인스턴스를 생성할 수 없다. 추상 클래스는 상속을 통해서 자식클래스에 의해서만 완성될 수 있다.

클래스 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있다.

공통된 부분을 추상 클래스로 만들고 이를 상속 받는 여러 클래스의 구조로 만들 수 있다.

### 추상 메서드(abstract method)

메서드를 선언부만 만들고 구현부는 작성하지 않은채 남겨 둔것이 추상 메서드.

그 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문.

```java
abstract 리턴타입 메서드이름();
```

추상클래스로부터 상속받는 자식클래스는 오버라이딩을 통해 부모인 추상클래스의 추상메서드를 모두 구현해주어야 한다. 만약 부모로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자식클래스 역시 추상클래스로 지정해 주어야 한다.

### 추상클래스의 작성

여러 클래스의 공통적으로 사용될 수 있는 클래스를 바로 작성하기도 하고, 기존의 클래스의 공통적인 부분을 뽑아서 추상클래스로 만들어 상속하도록 하는 경우도 있다.

상속이 자식클래스를 만드는데 부모클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통부분을 뽑아내서 부모클래스를 만드는 것이라고 할 수 있다.

### 인터페이스

인터페이스는 일종의 추상클래스이다.

인터페이스는 추상클래스처럼 추상메서드를 갖지만, 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.

오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.

추상 클래스 = 미완성 설계도, 인터페이스 = 기본 설계도

```java
interface 인터페이스이름 {
		public static final 타입 상수이름 = 값;
		public abstract 메서드이름(매개변수목록);
}
```

제약사항

- Interface에도 클래스처럼 접근제어자로 public 또는 default만 사용할 수 있다.
- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다. (컴파일러가 자동으로 붙여줌)
- 모든 메서드는 public abstract 이어야하며, 이를 생략할 수 있다.

### 인터페이스의 상속

인터페이스는 인터페이스로부터만 상속 받을 수 있다.

클래스와 달리 다중상속이 가능하다.

### 인터페이스의 구현

인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없다.

인터페이스는 상속 받는 클래스에 구현한다는 의미의 키워드인 `implements`를 사용한다.

만약 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.

그리고 상속과 구현을 동시에 할 수도 있다.

### 인터페이스를 이용한 다형성

상속관계에서 부모타입이 자식타입을 참조할 수 있는 것 처럼 인터페이스도 구현한 클래스를 참조할 수도 있고

구현한 클래스를 인터페이스 타입으로 형변환도 가능하다.

메서드의 매개변수 타입으로 인터페이스가 사용 가능. → 호출 시 인터페이스를 구현한 클래스 타입을 넘겨야 한다.

메서드의 리턴타입으로 인터페이스를 지정하는 것도 가능. → 인터페이스를 구현한 클래스의 인스턴스를 반환해야 한다.

### 인터페이스의 장점

1. 개발시간을 단축시킬 수 있다.
2. 표준화가 가능하다.
3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
4. 독립적인 프로그래밍이 가능하다.

### 디폴트 메서드와 static메서드

원래는 인터페이스에 추상 메서드만 선언할 수 있었는데, 자바8부터 디폴트 메서드와 static메서드도 가능.

인터페이스에 새로운 추상메서드를 추가하면 이를 구현한 모든 클래스들이 새로 추가된 메서드를 구현해야 한다.

이러한 문제 때문에 디폴트 메서드라는 것이 고안되었다. 이는 추상메서드가 아니기 때문에 강제적으로 구현하지 않아도 된다.

```java
interface MyInterface {
		void method();
		default void newMethod(){}
}
```

 

### 내부 클래스(inner class)

클래스 내에 선언된 클래스.

클래스에 다른 클래스를 선언하는 이유는 간단하다. 두 클래스가 서로 긴밀한 관계이기 때문.

장점

- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능
- 코드의 복잡성을 줄일 수 있다.(캡슐화)

```java
class A { // 외부 클래스
		...
		class B {  // 내부 클래스
				...
		}
		...
}
```

이때 내부 클래스 B는 외부 클래스 A를 제외하고 다른 클래스에서 잘 사용되지 않아야한다.

### 내부 클래스의 종류와 특징

내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다.

내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있으며, 변수의 선언위치에 따라 인스턴스 변수, 클래스 변수, 지역변수로 구분되는 것과 같이 내부 클래스도 선언위치에 따라 구분된다.

### 내부 클래스의 제어자와 접근성

내부 클래스 중에서 스태틱 클래스만 static멤버를 가질 수 있다. (드문 경우다)

이때 final과 static이 같이 사용되면 상수이므로 허용

인스턴스클래스는 외부 클래스의 인스턴스멤버를 객체생성 없이 바로 사용할 수 있지만, 스태틱 클래스는 외부 클래스의 인스턴스멤버를 객체생성 없이 사용할 수 없다.

마찬가지로 인스턴스클래스는 스태틱 클래스의 멤버들을 객체생성 없이 사용할 수 있지만, 스태틱 클래스에서는 인스턴스클래스의 멤버들을 객체생성 없이 사용할 수 없다.

### 익명 클래스(anonymous class)

클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스.

```java
new 부모클래스이름() {
		// 멤버 선언
}

		또는

new 구현인터페이스이름() {
		//멤버 선언
}
```

이름이 없기 때문에 생성자도 가질 수 없으며, 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만 구현 가능.
