# CHAPTER 14 람다와 스트림

### **람다식**

메서드를 하나의 ‘식’으로 표현한 것. 람다식은 함수를 간략하면서도 명확하게 표현할 수 있게 해준다.

메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 ‘익명 함수’라고도 한다.

```java
int[] arr = new int[5];
Arrays.setAll(arr, (i) -> (int)(Math.random()*5)+1);
```

### 람다식 작성하기

메서드의 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{ } 사이에 ‘->’를 추가하기만 하면 된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99dfd5ef-d0e5-4cac-8ee0-8f27ef20c73b/Untitled.png)

반환값이 있는 메서드의 경우, return문 대신 ‘식’으로 대신 할 수 있다. 식의 연산결과가 자동적으로 반환값이 된다. 이때는 ‘문장’이 아닌 ‘식’이므로 끝에 ‘;’을 붙이지 않는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a1307d2-d172-4b09-9e31-7491b0ac4d57/Untitled.png)

람다식에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5501c09b-9cd0-461f-8900-f343fcb4207c/Untitled.png)

괄호{ } 안의 문장이 하나일 때는 괄호{ }를 생략할 수 있다. 이 때 문장의 끝에 ‘;’을 붙이지 않아야 한다.

### 람다식은 익명 함수? 익명 객체!

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데, 람다식은 어떤 클래스에 포함되는 것일까?

람다식이 메서드와 동등한 것처럼 설명해왔지만, 사실 람다식은 익명 클래스의 객체와 동등하다.

람다식으로 정의된 익명 객체의 메서드를 어떻게 호출할까?

```java
타입 f = (int a, int b) -> a > b ? a : b; //참조변수의 타입을 뭘로 해야 할까?
```

참조변수 f의 타입은 클래스 또는 인터페이스가 가능하다.

그리고 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다. 그래야 참조변수로 익명 객체(람다식)의 메서드를 호출할 수 있기 때문이다.

### 함수형 인터페이스

아래와 같이 메서드 max가 선언된 MyFunction인터페이스가 정의되어 있다고 가정하자.

```java
interface MyFunction {
	public abstract int max(int a, int b);
}
```

이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성할 수 있다.

```java
MyFunction f = new MyFunction() {
											public int max(int a, int b) {
														return a > b ? a : b;
											}
							};
int big = f.max(5, 3); //익명 객체의 메서드를 호출
```

위 코드의 익명 객체를 람다식으로 아래와 같이 대체할 수 있다.

```java
MyFunction f = (int a, int b) -> a > b ? a : b; //익명 객체를 람다식으로 대체
int big = f.max(5, 3); //익명 객체의 메서드를 호출 
```

이처럼 MyFunction인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는, 람다식도 실제로는 익명 객체이고, MyFunction인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.

이처럼 완전히 대체가 가능하기 때문에 람다식을 다루기 위한 인터페이스, **‘함수형 인터페이스’**가 등장했다.

```java
@FunctionalInterface
interface MyFunction {
	public abstract int max(int a, int b);
}
```

함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다.

그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다.

### 함수형 인터페이스 타입의 매개변수, 반환 타입

함수형 인터페이스 MyFunction이 아래와 같이 정의되어 있을때,

```java
@FunctionalInterface
interface MyFunction {
	void myMethod(); //추상 메서드
}
```

메서드의 매개변수가 MyFunction타입이면, 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻이다.

```java
void aMethod(MyFunction f) { //매개변수의 타입이 함수형 인터페이스
	f.myMethod();              //MyFunction에 정의된 메서드 호출
}
	...
Myfunction f = () -> System.out.println("MyMethod()");
aMethod(f);
```

또는 참조변수 없이 아래와 같이 직접 람다식을 매개변수로 지정하는 것도 가능 하다.

```java
aMethod(() -> System.out.println("myMethod()")); //람다식을 매개변수로 지정
```

메서드의 반환타입이 함수형 인터페이스타입이라면, 이 함수형 인터페이스의 추상메서드의 동등한 람다식을 카리키는 참조변수를 반환하거나 람다식을 직접 반환할 수 있다.

```java
MyFunction myMethod() {
	MyFunction f = () -> {};
	return f;
}
```

함수형 인터페이스를 사용하는 다양한 방법

```java
@FunctionalInterface
interface MyFunction {
    void run();
}

public class Main {
    static void execute(MyFunction f) {
        f.run();
    }

    static MyFunction getMyFunction() {
        MyFunction f = () -> System.out.println("f3.run()");
        return f;
    }

    public static void main(String[] args) throws Exception{
        //람다식으로 MyFunction의 run()구현
        MyFunction f1 = () -> System.out.println("f1.run()");

        MyFunction f2 = new MyFunction() {
            @Override
            public void run() {
                System.out.println("f2.run()");
            }
        };

        MyFunction f3 =getMyFunction();

        f1.run();
        f2.run();
        f3.run();

				execute(f1);
				execute(() -> System.out.println("run()"));
    }
}
```

### java.util.function패키지

java.util.function패키지에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 저으이해 놓았다.

매번 새로운 함수형 인터페이스를 정의하지말고, 가능하면 이 패키지의 인터페이스를 활용하는 것이 좋다. (메서드 이름 통일, 재사용성, 유지보수)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa40aed9-9a6c-438a-8c73-9a43215f33c7/Untitled.png)

**매개변수가 두 개인 함수형 인터페이스**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76fd2945-2137-4351-9913-0e7fca7e7549/Untitled.png)

**UnaryOperator와 BinaryOperator**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ecec9444-dba6-40f5-8d51-e4c367b89d51/Untitled.png)

```java
public class Main {
    public static void main(String[] args) throws Exception{

        Supplier<Integer> s = () -> (int)(Math.random()*100)+1;
        Consumer<Integer> c = i -> System.out.println(i+", ");
        Predicate<Integer> p = i -> i%2==0;
        Function<Integer, Integer> f = i -> i/10*10;

        List<Integer> list = new ArrayList<>();
makeRandomList(s, list);
        System.out.println(list);
printEvenNum(p, c, list);
        List<Integer> newList =doSomething(f, list);
        System.out.println(newList);
    }

    static <T> List<T> doSomething(Function<T,T> f, List<T> list) {
        List<T> newList = new ArrayList<T>(list.size());

        for (T i : list) {
            newList.add(f.apply(i));
        }
        return newList;
    }

    static <T> void printEvenNum(Predicate<T> p, Consumer<T> c, List<T> list) {
        System.out.println("[");
        for (T i : list) {
            if(p.test(i))
                c.accept(i);
        }
        System.out.println("]");
    }

    static <T> void makeRandomList(Supplier<T> s, List<T> list) {
        for(int i=0; i<10; i++) {
            list.add(s.get());
        }
    }

}
```

### Predicate의 결합

여러 조건식을 논리 연산자인 &&(and), ||(or), !(not)으로 연결해서 하나의 식을 구성할 수 있는 것처럼, 여러 Predicate를 and(), or(), negate()로 연결해서 하나의 새로운 Predicate로 결합할 수 있다.

```java
Predicate<Integer> p = i -> i < 100;
Predicate<Integer> q = i -> i < 200;
Predicate<Integer> r = i -> i%2 == 0;
Predicate<Integer> notP = p.negate();    // i >= 100

// 100 <= i && (i < 200 || i%2==0)
Predicate<Integer> all = notP.and(q.or(r));
System.out.println(all.test(150));  //true
```

### 컬렉션 프레임웍과 함수형 인터페이스

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b038029a-bc09-4cdf-a08d-a024ff144ea5/Untitled.png)

```java
public class Main {
    public static void main(String[] args) throws Exception{

        ArrayList<Integer> list = new ArrayList<>();
        for(int i=0; i<10; i++)
            list.add(i);

        //list의 모든 요소를 출력
        list.forEach(i -> System.out.print(i+","));
        System.out.println();

        //list에서 2 또는 3의 배수를 제거한다.
        list.removeIf(x -> x%2==0 || x%3==0);
        System.out.println(list);

        list.replaceAll(i ->i*10);  //list의 각 요소에 10을 곱한다.
        System.out.println(list);

        HashMap<String, String> map = new HashMap<>();
        map.put("1", "1");
        map.put("2", "2");
        map.put("3", "3");
        map.put("4", "4");

        //map의 모든 요소를 {k, v}의 형식을 출력한다.
        map.forEach((k, v) -> System.out.println("{"+k+","+v+"},"));
        System.out.println();

    }

}
```

### 메서드 참조

람다식이 **하나의 메서드만 호출하는 경우**에는 ‘메서드 참조’라는 방법으로 람다식을 간략히 할 수 있다. 예를들어 문자열을 정수로 변환하는 람다식은 아래와 같이 작성할 수 있다.

```java
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
```

이를 ‘메서드 참조’ 방식으로 작성하면 다음과 같다.

```java
Function<String, Integer> f = Integer::parseInt; //메서드 참조
```

메서드 참조에서 람다식의 일부가 생략되었지만, 컴파일러는 생략된 부분을 우변의 parseInt메서드의 선언부로부터, 또는 좌변의 Function인터페이스에 지정된 지네릭 타입으로부터 쉽게 알아낼 수 있다.

하나의 메서드만 호출하는 람다식은 ‘클래스이름::메서드이름’ 또는 ‘참조변수::메서드이름’으로 바꿀 수 있다.

### 생성자의 메서드 참조

생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다.

```java
Supplier<MyClass> s = () -> new MyClass(); //람다식
Supplier<MyClass> s = MyClass::new;        //메서드 참조
```

매개변수가 있는 생성자면, 매개변수 개수에 따라 함수형 인터페이스 사용

```java
Function<Integer, MyClass> f = (i) -> new MyClass(i); //람다식
Function<Integer, MyClass> f2 = MyClass::new;         //메서드 참조

Bifunction<Integer, String, MyClass> bf = (i,s) -> new MyClass(i,s);
Bifunction<Integer, String, MyClass> bf2 = MyClass::new; //메서드 참조
```

배열 생성

```java
Function<Integer, int[]> f = x -> new int[x];  //람다식
Function<Integer, int[]> f2 = int[]::new;      //메서드 참조
```

메서드 참조는 람다식을 마치 static변수처럼 다룰 수 있게 해준다. 메서드 참조는 코드를 간략히 하는데 유용해서 많이 사용된다.

### 스트림

지금까지 데이터를 다룰때, 컬렉션이나 배열에 데이터를 담고 원하는 결과를 얻기 위해 for문과 Iterator를 이용했다.

이러한 방식으로 작성된 코드는 간결하지 않고 재사용성도 떨어진다.

또 다른 문제는 데이터 소스마다 다른 방식으로 다뤄야한다는 것이다.

Collection이나 Iterator와 같은 인터페이스를 이용해서 컬렉션을 다루는 방식을 표준화했지만, 각 컬렉션 클래스에는 같은 기능의 메서드들이 중복해서 정의되어 있다. (Collections.sort(), Arrays.sort())

이러한 문제점들을 해결하기 위해 **스트림**이 만들어졌다.

스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다.

데이터 소스를 추상화하였다는 것은, 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.

스트림을 이용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.

### 스트림의 특징

1. **스트림은 데이터 소스를 변경하지 않는다.**

스트림은 데이터소스로 부터 읽기만 하고 변경하지 않는다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수 있다.

```java
//정렬된 결과를 새로운 List에 담아서 반환한다.
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

1. **스트림은 일회용이다.**

스트림은 Iterator처럼 일회용이다. 

1. **스트림은 작업을 내부 반복으로 처리한다.**

스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 ‘내부 반복’이다. 

forEach()는 스트림에 정의된 메서드 중 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다.

```java
stream.forEach(System.out.println);
```

1. **지연된 연산**

스트림 연산은 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다.

스트림에 대해 distinct()나 sort()같은 중간 연산을 호출해도 즉각적인 연산이 수행되지 않는다.

1. **Stream<Integer>와 IntStream**

요소의 타입이 T인 스트림은 기본적으로 Stream<T>이지만, 오토박싱&언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 스트림, IntStream, LongStream, DoubleStream이 제공된다.

일반적으로 Stream<Integer> 대신 IntStream을 사용하는것이 더 효율적

1. **병렬 스트림**

스트림으로 데이터를 다룰 때의 장점 중 하나가 바로 병렬 처리가 쉽다는 것이다.

병렬 스트림은 내부적으로 Java에서 제공하는 fork&join프레임웍을 이용해서 자동적으로 연산을 병렬로 수행한다.

병렬로 연산을 수행하기 위해선 parallel() 메서드를 호출하기만 하면 된다.

반대로 병렬 처리가 되지 않게 하기 위해선 sequential()을 호출하면 된다.

모든 스트림은 기본적으로 병렬 스트림이 아니므로 sequential()을 호출할 필요가 없다.

### 스트림 만들기 - 컬렉션

스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등 다양하다.

컬렉션의 최고 조상인 Collection에 stream()이 정의되어 있다.

그래서 Collection의 자손인 List와 Set을 구현한 컬렉션 클래스들은 모두 스트림을 생성할 수 있다.

stream()은 해당 컬렉션을 소스로 하는 스트림을 반환한다.

```java
Stream<T> Collection.stream()
```

List로부터 스트림을 생성하는 코드

```java
List<Integer> list = Arrays.asList(1,2,3,4,5); //가변인자
Stream<Integer> intStream = list.stream();     //list를 소스로 하는 스트림 생성
```

forEach()는 지정된 작업을 스트림의 모든 요소에 대해 수행한다.

```java
intStream.forEach(System.out::println); //스트림의 모든 요소를 출력한다.
intStream.forEach(System.out::println); //에러. 스트림 재사용 불가능
```

### 스트림 만들기 - 배열

배열을 소스로 하는 스트림을 생성하는 메서드는 Stream과 Arrays에 static메서드로 정의되어 있다.

```java
Stream<T> Stream.of(T... values) //가변 인자
Stream<T> Stream.of(T[])
Stream<T> Arrays.stream(T[])
Stream<T> Stream.of(T[] array, int startInclusive, int endExclusive)
```

예를 들어 문자열 스트림은 다음과 같이 생성

```java
Stream<String> strStream = Stream.of("a", "b", "c"); //가변 인자
Stream<String> strStream = Stream.of(new String[]{"a", "b", "c"});
Stream<String> strStream = Arrays.stream(new String[]{"a", "b", "c"});
Stream<String> strStream = Arrays.stream(new String[]{"a", "b", "c"}, 0, 3);
```

int, long, double과 같은 기본형 타입도 지원.

### 스트림 만들기 - 임의의 수

Random클래스에는 아래와 같은 인스턴스 메서드들이 포함되어 있다.

이 메서드들은 해당 타입의 난수로 이루어진 스트림을 반환한다.

```java
IntStream ints()
LongStream longs()
DoubleStream doubles()
```

이 메서드들이 반환한 스트림들은 무한 스트림으로 크기가 정해져 있지 않다.

그래서 limit()도 같이 사용해서 스트림의 크기를 제한해 주어야 한다. (유한 스트림으로 만들어줌)

```java
IntStream intStream = new Random().ints(); //무한 스트림
intStream.limit(5).forEach(System.out::println); // 5개의 요소만 출력
```

처음부터 유한스트림으로 생성할 수 있다.

```java
IntStream intStream = new Random().ints(5); //크기가 5인 난수 스트림을 반환
```

### 스트림 만들기 - 특정 범위의 정수

IntStream과 LongStream은 다음과 같이 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 range()와 rangeClosed()를 가지고 있다.

```java
IntStream IntStream.range(int begin, int end)
IntStream IntStream.rangeClosed(int begin, int end)
```

range()의 경우 경계의 끝인 end가 범위에 포함되지 않고, rangeClosed()의 경우는 포함된다.

### 스트림 만들기 - 람다식 iterate(), generate()

Stream클래스의 iterate()와 generate()는 람다식을 매개변수로 받아서, 이 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다.

```java
static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
static <T> Stream<T> generate(Supplier<T> s)
```

**iterate()**

```java
Stream<Integer> evenStream = Stream.iterate(0, n->n+2); //0, 2, 4, 6, ...
```

**generate()**

```java
Stream<Double> reandomStream = Stream.generate(Math::random);
Stream<Integer> oneStream = Stream.generate(() ->1)
```

매개변수가 없는 람다식만 허용한다.

주의할점은 iterate()와 generate()에 의해 생성된 스트림을 아래와 같이 기본형 스트림 타입의 참조변수로 다룰수 없다.

```java
IntStream evenStream = Stream.iterate(0, n->n+2); //에러
DoubleStream randomStream = Stream.generate(Math::random); //에러
```

굳이 필요하면, 아래와 같이 mapToInt()메서드로 변환
