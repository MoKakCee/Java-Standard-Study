# CHAPTER 3 연산자

**연산자**

+, -, *, / 등

**피연산자**

연산의 대상

**연산자의 우선순위**

식에서 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정

- 단항 연산자(부호 연산자)가 이항 연산자(+, -, *, /)보다 우선순위가 높다.
    - -x + 3 → -로 먼저 부호를 바꾸고 덧셈 수행

**연산자의 결합규칙**

산술 연산자(+, -, *, /)의 경우 왼쪽부터 연산 진행 (3+4-5)

대입 연산자의 경우 오른쪽부터 연산 진행 (x=y=3)

**산술 → 비교 → 논리 → 대입 연산자 순서로 진행**

**형변환 연산자(캐스트 연산자)**

형변환은 지정된 타입으로 형변환 후 **반환**한다. 그래서 기존 데이터는 변화 없다.

작은타입에서 큰타입은 형변환 가능하지만, 큰타입에서 작은타입은 형변환 불가능.

**산술 변환**

이항 연산자는 두 피연산자의 타입이 일치해야 연산 가능

이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 **산술 변환**

너무 작은 타입들(byte)로 연산을 진행할 경우 오버플로우가 발생할 수 있어 자동으로 int로 형변환

큰타입(long) + 작은타입(int)로 연산할 경우 두 피연산자의 타입을 자동으로 같게 일치시킨다. (큰 타입으로 변환 long+long=long으로 변환)

**오버플로우가 발생하기 전에 형변환을 하자**

```java
int a = 1000000 //1백만
int b = 2000000 //2백만

long c = a * b;

System.out.println(c);
```

예상한 결과는 2000000000000 이지만 위의 코드 결과는 -1454759936로 오버플로우가 발생한것을 확인할수 있다.

long c = (long) a* b; 처럼 명시적 형변환을 해야한다.

**Math.round()로 반올림하기**

`Math.round(4.52)` → 결과값은 5

**비교 연산자**

비교 연산자 역시 이항 연산자에 속한다.

**대소비교 연산자** <, >, <=, >=

**등가비교 연산자** ==, !=

등가비교 연산자는 모든 자료형(기본형, 참조형)에 사용할 수 있다.

기본형의 경우 단순 값 비교

참조형의 경우 객체의 주소값을 비교

**문자열의 비교**

두 문자열을 비교할 때는, 비교 연산자 ‘==’ 대신 equals()라는 메서드를 사용.

String은 클래스로 ‘==’ 사용시 담겨있는 값을 비교하는게 아닌 주소를 비교한다.

만약 대소문자를 구별하지 않고 비교하고 싶다면 equalsIgnoreCase()를 사용.

**논리 연산자**

&&, ||, !

&&가 ||보다 우선으로 작동한다. 

입력 받은 문자에 숫자가 있는지 확인할려면 

`‘0’ <= ch && ch <=’9’`

이는 유니코드에서 문자 ‘0’부터 ‘9’까지 연속적으로 배치되어 있기 때문에 가능

마찬가지로

알파벳도 가능

`‘a’ <= ch && ch <=’z’`

**조건 연산자**

조건식? 식1 : 식2

true면 식1, false면 식2

만약 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술변환이 발생한다.

**대입 연산자**

우선순위가 가장 낮다.

lvalue = rvalue;

lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.

**복합 대입 연산자**

i+=3; 와 i=i+3;는 같은 식이다.

대입 연산자의 우변이 둘 이상의 항으로 이루어져 있는 경우

i *= 10 + j; 는 i = i * (10 + j);로 된다.
