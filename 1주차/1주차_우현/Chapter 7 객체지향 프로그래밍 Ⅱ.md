# CHAPTER 7 객체지향프로그래밍Ⅱ

**상속**

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

- 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 좋음
- `extends` 키워드

```java
class Parent { }
class Child extends Parent {
	//...
}
```

**부모클래스 - 자식클래스**

- 부모클래스에 멤버변수, 메서드를 추가하면 자식클래스도 자동적으로 추가된다.
- 반대로 자식클래스에 멤버변수, 메서드를 추가하면 부모클래스에게는 아무런 영향도 없다.
- 그렇기에 자식클래스는 부모클래스보다 같거나 많은 멤버를 갖는다.
- extends의 뜻은 확장이다.

**정리하면**

1. 자식 클래스는 부모 클래스의 모든 멤버를 상속받는다. (단, 생성자와 초기화 블럭은 상속되지 않는다.)
2. 자식 클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다.
3. 자식클래스의 인스턴스를 생성하면 부모클래스의 멤버도 함께 생성되기 때문에 따로 부모클래스의 인스턴스를 생성하지 않고도 부모클래스의 멤버들을 사용할 수 있다.

**클래스 간의 관계 - 포함관계**

상속이외에도 클래스를 재사용하는 또 다른 방법이 있는데, 그것은 클래스 간에 `포함`관계를 맺어 주는 것이다. 

클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
class Point {
	int x;
	int y;
}
```

```java
class Circle {
	Point c = new Point(); //포함관계
	int r;
}
```

**클래스 간의 관계 결정하기**

클래스를 작성할때 언제 상속관계를 맺고, 언제 포함관계를 맺을까?

**상속관계:** ‘~은 ~이다. (is-a)’

**포함관계:** ‘~은 ~을 가지고 있다. (has-a)’

ex) sportsCar는 Car다. → 상속

Deck은 Card를 가지고 있다 → 포함

**단일상속**

자바에서는 다중상속이 불가능

**Object클래스 - 모든 클래스의 부모**

Object클래스는 모든 클래스 상속계층도의 최상위에 있는 부모클래스이다.

다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

다른 클래스로부터 상속받더라도 상속계층도를 따라 올라가면 결국 Object클래스로부터 상속받는다.

그래서 자바의 모든 클래스들은 Object클래스에 정의된 멤버들을 사용할 수 있다.

그동안 toString()이나 equals(Object 0)와 같은 메서드를 따로 정의하지 않고도 사용할 수 있었던 이유이다.

**오버라이딩**

부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버리이딩이라 한다.

상속받은 메서드를 그냥 사용해도 되지만, 자식 클래스에 맞게 변경해서 사용하는 경우가 많다.

**오버라이딩 조건**

1. 메서드의 선언부(메서드 이름, 매개변수, 반환타입)이 부모의 것과 완전히 일치해야 한다.

다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경 가능.

1. 접근 제어자는 부모 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
- private < (default) < protected < public
1. 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

**오버로딩과 오버라이딩**

**오버로딩**: 기존에 없는 새로운 메서드를 정의하는 것

**오버라이딩**: 상속받은 메서드의 내용을 변경하는 것

**참조변수 super**

super는 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.멤버변수와 지역변수의 이름이 같을때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버를 구별할때 super를 사용한다.

super키워드를 사용해서 부모클래스의 멤버를 지칭할 수 있다. 

**super() - 조상의 생성자**

this()처럼 super()도 생성자다.

this()는 같은 클래스의 다른 생성자를 호출하는데 사용, super()는 부모의 생성자를 호출하는데 사용

상속 관계에서 각 클래스의 멤버변수 초기화 할때는 해당 클래스의 생성자를 통해 초기화 하는게 좋은 방법이다.

```java
class Point {
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point {
	int z;

	Point3D(int x, int y, int z) {
		//부모클래스의 멤버를 자식이 직접 초기화는 별로 좋지 않은 방법
		//this.x = x;
		//this.y = y;

		super(x, y);  //부모클래스의 생성자를 통한 초기화를 하자
		this.z=z;  //자신의 멤버 초기화
	}
}
```

**패키지**

같은 이름의 클래스라도 패키지가 다르면 다른 클래스로 취급.

패키지명은 소문자로 하는게 원칙.

패키지에 속하지 않은 클래스들은 모두 `이름 없는 패키지` 에 속하게 된다.

**import문**

소스코드에서 사용되는 클래스이름에서 패키지명을 생략할 수 있게 해준다.

**static import문**

static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

**제어자**

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여

**접근 제어자:** public, protected, default, private

**그 외:** static, final, abstract, native, transient, synchronized, volatile, strictfp
