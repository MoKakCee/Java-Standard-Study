# ****Chapter 3 연산자****

## 연산자

- `연산을 수행하는 기호`
- 자바에서는 사칙연산을 비롯하여 다양한 연산자를 제공한다.
- 연산자가 연산을 수행하려면 반드시 하나 이상의 연산의 대상이 있어야 하는데, 이것을 **피연산자(operand)** 라고 표현한다.
- 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것을 **식(expression)** 이라고 표현한다.
- 이러한 식을 계산하여 결과를 얻는 것을 **식을 평가(evaluation)한다** 라고 표현한다.
- 하나의 식을 평가(계산)하면 단 하나의 결과를 얻는다.

## **연산자의 종류**

| 종류 | 연산자 | 설명 |
| --- | --- | --- |
| 산술 연산자 | +, -, *, %, <<, >> | 사칙 연산과 나머지 연산(%) |
| 비교 연산자 | >, <, >=, <=, ==, != | 두 피연산자를 비교 |
| 논리 연산자 | &&, |  |
| 대입 연산자 | = | 우변의 값을 좌변에 저장 |
| 부호 연산자 | -, + | 해당 값의 부호를 명시 |
| 기타 | (type) ?: instanceof | 형변환 연산자, 삼항 연산자, instanceof 연산자 |
- 연산자는 피연산자의 개수로 연산자를 분류하기도 하며, 피연산자의 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자라고 표현한다.
- 대부분의 연산자는 **이항 연산자**이다.

## **증감 연산자 ++과 --**

- 증감 연산자는 피연산자에 저장된 값을 1 증가 또는 감소시킨다.
- 상수의 경우 한 번 저장한 값을 변경할 수 없기 때문에 사용할 수 없다.
- 0 증감 연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않으며, 그러므로 연산결과의 타입은 피연산자의 타입과 같다.

> 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.감소 연산자(--) : 피연산자의 값을 1 감소시킨다.
>

## **자동 형변환**

- 서로 다른 타입 간의 대입이나 연산을 할 때, 먼저 형변환으로 타입을 일치시키는 것이 원칙이지만 편의상의 이유로 형변환을 생략할 수 있다.
- 이렇게 생략한 경우는 형변환이 이루어지지 않는 것은 아니며, 컴파일러가 생략된 형변환을 자동으로 추가해준다.
- 형변환 연산자를 사용하는 경우 이를 **명시적 형변환** 이라고 표현하며, 자동 형변환의 경우 **묵시적 형변환** 이라고 표현한다.

## **산술 변환**

- 이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.
- 이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 산술 변환 또는 일반 산술 변환이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.

### **산술 변환의 규칙이다.**

1. 두 피연산자의 타입을 비교하여 보다 큰 타입으로 일치시킨다.

```java
long + int => long + long => long
float + int => float + float => float
double + float => double + double => double
```

1. 피연산자의 타입이 정수이고 int보다 작은 값이면 int로 변환된다.

```java
byte + short => int + int => int
char + short => int + int => int
```

1. 피연산자의 타입이 실수이고 double보다 작은 값이면 double로 변환된다.

```java
float + float => double + double => float
```

- 첫 번째 규칙은 피연산자의 값 손실을 최소화하기 위함이고, 두 번째, 세 번째 규칙은 int형보다 작은 타입의 경우 표현범위가 좁아서 연산 중에 오버플로우가 발생할 가능성이 높기 때문이다.
- 그렇기 때문에 정수형의 기본 타입을 int, 실수형의 기본 타입을 double이라고 표현한다.
- 그리고 또 하나 주의할 점은 연산결과의 타입인데, 연산결과의 타입은 피연산자의 타입과 일치한다는 점이다.

```java
byte a = 10;
byte b = 20;
byte c = a + b;
```

- **위 예시는 컴파일 에러가 발생한다.**
- 그 이유는 int보다 작은 데이터 타입을 연산할 때에는 int로 묵시적 형변환이 이루어지기 때문에, byte c = a + b => byte c = (int)a + (int)b와 같은 동작이 되기 때문에 반환값도 int이지만 int보다 표현 범위가 작은 byte 타입의 변수 c로 반환값을 받으려고 했기 때문이다.
- **이러한 에러를 없애기 위해서는**

```java
byte a = 10;
byte b = 20;
byte c = (byte)(a + b);
```

- **혹은**

```java
byte a = 10;
byte b = 20;
int c = a + b;
```

- **위와 같은 변경이 필요하다.**

```java
class Ex3_9 {
    public static void main(String args[]) {
    int a = 1_000_000; // 1,000,000 1백만
    int b = 2_000_000; // 2,000,000 2백만
    long c = a * b; // a * b = 2,000,000,000,000 ?
    System.out.println(c);
    }
}
```

- **다음 예시에서도 문제가 발생한다.**
- long 타입은 2,000,000,000,000을 담을 수 있기 때문에 문제가 없어 보이지만, 앞서 학습한 내용처럼 식의 반환값은 피연산자의 타입과 일치한다는 점으로 인해 문제가 발생한다.
- a * b의 타입은 모두 int * int이기 때문에, 반환값 또한 int가 되며 int의 표현 범위는 -214748648 ~ 2147483647로 2,000,000,000,000을 담을 수 없기 때문에 오버플로우가 발생하며, 오버플로우가 발생한 값이 long 타입 변수에 저장되기 때문이다.

```java
long c = a * b;
=> long c = 1000000 * 2000000;
=> long c = -1454759936;

1000000 * 1000000 => -727379968
```

- 그렇기 때문에 올바른 결과를 얻으려면 a 또는 b의 타입을 long으로 바꿔 묵시적 형변환을 통해 오버플로우를 방지해야 한다.

```java
long c = (long)a * b;
=> long c = (long)1000000 * 2000000;
=> long c = 1000000L * 2000000;
=> long c = 1000000L * 2000000L;
=>  long c = 2000000000000L;

1000000 * 1000000L => 1000000L * 1000000L => 1000000000000L
```

## **Math.round()로 반올림하기**

- Math.round() 메소드를 통해 반올림이 가능하다.
- 해당 메소드는 소수점 첫 번째 자리에서 반올림한 결과를 정수로 반환한다.
- 그러므로 소수점 첫 번째 자리가 아닌 다른 자리에서 반올림을 하려면 10^n을 곱하고 다시 곱한 값으로 나누어야 한다.

```java
class Ex3_11 {
    public static void main(String args[]) {
    double pi = 3.141592;
    double shortPi = Math.round(pi * 1000) / 1000.0;
    System.out.println(shortPi);
    }
}
```

- **이 예제의 동작 과정은 다음과 같다.**

```java
Math.round(pi * 1000) / 1000.0
=> Math.round(3.141592 * 1000) / 1000.0
=> Math.round(3141.592) / 1000.0
=> 3142 / 1000.0
=> 3.142
```

## **문자열의 비교**

- 위에서 살펴본 등가비교 연산자의 경우 참조형은 객체의 주소값을 비교하여 두 개의 참조 변수가 서로 같은 객체를 가리키고 있는지를 비교한다고 학습했다.
- **String** 또한 참조형이기 때문에 객체의 주소값을 비교하게 되는데, 문자열의 경우 주로 내용을 비교하기 때문에 등가비교 연산자를 사용하기에는 적합하지 않다.

```java
String s1 = "aaa"; // String s1 = new String("aaa");
String s2 = "aaa"; // String s2 = new String("aaa");

System.out.prinln(s1 == s2) / / 무조건 false 출력
```

- s1과 s2는 값이 "aaa"로 같지만, 가리키고 있는 객체는 서로 다르기 때문에 무조건 false가 출력된다.
- 그렇기 때문에 문자열을 비교할 때에는 객체의 주소값을 비교하는 것이 아닌 객체에 담긴 값을 비교해야 하며, 이러한 역할을 수행하는 메소드는 String 클래스에 포함되어 있는 equals() 메소드이다.

```java
String s1 = "aaa"; // String s1 = new String("aaa");
String s2 = "aaa"; // String s2 = new String("aaa");

System.out.prinln(s1.equals(s2)) // true

String s3 = "aaa"; // String s3 = new String("aaa");
String s4 = "aAa"; // String s4 = new String("aAa");

System.out.println(s3.equals(s4)) // false
System.out.println(s3.equalsIgnoreCase(s4)) // true
```

- **여기서 문자열의 값을 비교할 때 대소문자를 무시하고 비교하고 싶다면** `equalsIgnoreCase()` **메소드를 사용하면 된다.**