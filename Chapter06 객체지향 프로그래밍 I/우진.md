# 객체지향 프로그래밍 1

### 객체지향언어

---

> **객체지향언어는 기존의 프로그래밍 언어에 몇가지 새로운 규칙을 추가해 보다 발전된 형태이다
이러한 규칙들을 이용해서 코드간에 서로 관계를 맺어 줌으로써 보다 유기적으로 프로그램을 구성하는 것이 가능해졌다.**
> 

```java
1. 코드의 재사용성이 높다.
  - 새로운 코드를 작성할 때 기존 코들르 이요하여 수비게 작성할 수 있다
2. 코드의 관리가 용이하다.
  - 코드간에 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 이싿.
3. 신뢰성이 높은 프로그래밍이 가능하게 한다.
  - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 죽복을
    제거하여 코드의 불일치로 인한 오작동을 방지할 수 있다.
```

- **상속, 다형성**은 재사용성과 유지보수 그리고 중복된 코드의 제거를 더 유연하게 한다.

### 클래스와 객체의 정의와 용도

---

> **클래스란 객체를 정의해 놓은것 또는 클래스는 객체의 설계도 또는 틀이다.
객체는 사물과 같은 유형적인 것 뿐아니라 개념이나 논리와같은 무형적인것도 객체로 간주한다**
> 
- 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
- 객체는 속성과 기능 속성과 다수의 기능 두 종류의 구성요소로 이루어져 있다.

```java
속성(perpertie) : 맴버변수, 특성, 필드, 상태
기능(funtion) : 메서드, 함수, 행위
```

### 인스턴스의 생성과 사용

---

```java
String str1 = "안녕";
String str2 = "하세요";

str2 = str1;
```

- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.
- 하나의 인스턴스를 가르키는 것은 가능하지만 하나의 참조변호로 여러 개의 인스턴스를 가리키는 것은 가능하지 않다.
    - 하나의 객체가 어려개의 주소를 참조할 수 없다.

### 클래스의 또 다른 정의

---

1. **클래스 - 데이터와 함수의 결합**

```java
변수 : 하나의 데이터를 저장할 수 있는 공간
배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
구조체 : 서로 관련된 여러 데이터를 종류에 관계 없이 하나의 집합으로 저장할 수 있는 공간
클래스 : 데이터와 함수의 결합(구조체 + 함수)
```

1. **클래스 - 사용자정의 타입**
    - 시간을 저장하는 함수를 만든다고 할 때의 코드이다.
        - 클래스 사용 이전에는 3개의 변수를 사용해 해당 로직을 구현했지만, 클래스 사용이후에는 좀더 객체지향적인 코드를 만들 수 있다.

```java
private void time(){
	int hour;
  int minute;
  float second;
}

class Time{
	int hour;
  int minute;
  float second;
}
```

### 변수의 종류

---

> **변수는 클래스변수, 인스턴스변수, 지역변수 모두 세 종류가 있다.**
> 

| 변수의 종류 | 선언 위치 | 생성시기 |
| :---: | :---: | :---: |
| 클래스 변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 | 클래스 영역 | 인스턴스가 생성되었을 때 |
| 지역 변수 | 클래스 영역 이외의 영역
(메서드, 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 |
1. **인스턴스 변수(intance variable)**
    - 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.
    - 인스턴스변수를 사용하기 위해선 먼저 인스턴스를 생성해야한다.
    - 인스턴스는 독립적은 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
2. **클래스 변수(class variable)**
    - 인스턴스 변수 앞에 static을 붙여 클래스 변수를 선언한다.
    - 클래스변수는 모든 인스턴스가 공통된 저장공간을 공유하게 된다.
    - 즉, 프로그램 내에서 어디서나 접근할 수있는 전역변수의 성격을 갖는다.
3. **지역변수(local variable)**
    - 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.
    

### 메서드

---

> **메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.**
> 
- **매서드를 사용해야하는 이유**
    1. **높은 재사용성(reusability)**
    2. **중복된 코드의 제거**
        - 반복되는 로직을 하나의 메서드로 작성해 놓으면 가독성 및 변경에 유연하다.
    3. **프로그램의 구조화**
        - 프로그램 구조화시 문제 발생을 쉽게 찾아서 해결할 수 있다.

### JVM의 메모리 구조

---

> **응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모르릴 할당 받고 JVM은 이 메모리를 용도에 영역에 따라 관리한다.**
> 
1. **메서드 영역(method area)**
    - 프로그램 실행 중 어떤 클래스가 사용되면, VM은 해당 클래스의 클래스파일을 분석하여 클래스에 대한 정보를 이곳에 저장한다.
    - 클래스변수도 이 영역에 함께 저장된다.
2. **힙(heap)**
    - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
    - 인스턴수변수 들이 생성되는 공간이다.
3. **호출스택(call stack or execution stack)**
    - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이메모리는 메서드가 작업을 수행하는 동안 연산 결과를 저장하는 등에 사용된다.
    - 메서드의 작업이 끝나면 할당된 메모리 공간은 반환되어 비워진다.

```java
public static void main(String[] args){
	System.out.println("main 시작");
  firstMethod();
	System.out.println("main 끝");
}

static void firstMethod(){
	System.out.println("firstMethod 시작");
  secondMethod();
	System.out.println("firstMethod 끝");
}

static void secondMethod(){
	System.out.println("SecondMethod 시작");
	System.out.println("SecondMethod 끝");
}
```

- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당 받는다.
- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

### 기본형 매개변수와 참조형 매개변수

---

> **기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.
참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.**
> 

```java
public static void main(String[] args){
	String name;
  int age = 0;
  change(age, name);
  System.out.println(age + " " + name);  // 0 json
}

private void change(int age, String name){
	age = 10;
  name = "json";
}
```

- `change`메서드 호출되면서 `age`는 `chage` 메서드의 매개변수의 `x`의 복사된다.
    - `name`의 경우 주소값을 매개변수 `name`에 복사한다.
- `change`메서드에서 `x`의 값을  `10`으로 변경, `name`을 `json`으로 변경
- `change`메서드가 종료되면서 매개변수는 스택에서 제거된다.

### 클래스 메서드와 인스턴스 메서드

---

> **인스턴스 메서드는 인ㅅ턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로하는 메서드이다.
인스턴스와 관련없는 메서드를 클래스 메서드로 정의한다.**
> 
1. 클래스를 설계할 때 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static 을 붙이는 것을 고려한다.

### 클래스 맴버와 인스턴스 맴버의 참조와 호출

---

> **인스턴스 맴버가 존재하는 시점에 클래스 맴버는 항상 존재하지만, 클래스 맴버가 존재하는 시점에 인스턴스 맴버가 존재하지 않을 수 있기 때문에 참조 또는 호출을 하고자하는 경우에 ㄱ인스턴스를 생성해야한다.**
> 

```java
class test{
	void instanceMethod() {}
  static void staticMethod() {}

  static void staticMethodErorr(){
    instanceMethod();  // 인스턴스 메서드를 호출할 수 없다.
    staticMethod();   
  } 

```

- 인스턴스간의 호출에는 아무런 문제가 없다.
- 하나의 인스턴스맴버가 존재한다는 것은 인스턴스가 이미 생성되어있다는 것을 의미한다.

### 오버로딩

---

> **오버로딩 : 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면 같은 이름을 사용해서 메서드를 정의할 수있다.**
> 
- **오버로딩의 조건**
    - 오버로딩된 메서들은 매개변수에 의해서만 구변될 수 있으므로 반환타입을 오버로딩을 구현하는데 아무런 영향을 주지 못한다.

```java
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야한다.
```

### 생성자

---

> **인스턴스가 생성될 대 호출되는 인스턴스 초기화 메서드이다.**
> 

```java
1. 생성자의 이름은 클래스의 이름과 같아야한다.
2. 생성자는 리턴 값이 없다.
```

- **기본 생성자**
    - 컴파일 시 클래스 내에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일한다.
    - 만약 기본생성자가 없는 클래스에 매개변수가 있는 생성자를 생성하고 기본 생성자를 통해 인스턴스를 생성한경우 에러가 발생한다.
- **생성자에서 다른 생성자를 호출**

```java
- 생성자의 이름을 클래스 이름대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 떄는 반드시 첫줄에서만 호출이 가능하다.
```

- this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
- this(), this(매개변수) : 생성자, 같은 클래스 내의 다른 생성자를 호출할 때 사용한다.

### 맴버변수의 초기화 시기와 순서

---

> 클래스변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화된다.
인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 한다.

클래스변수의 초기화 순서 : 기본값 → 명시적 초기화 → 클래스 초기화
인스턴스 변수의 초기화 순서 : 기본값 → 명시적초기화 → 인스턴스 초기화 → 생성자
> 

```java
class Init{
	static int cv = 1;
  int iv = 1;
  
  static { cv = 2 }
  {  iv = 2;  }
  Init(){  iv = 3 }
}
```

| 클래스초기화 |  |  | 인스턴스 초기화 |  |  |  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 기본값 | 명시적 초기화 | 클래스 초기화 블럭 | 기본값 | 명시적 초기화 | 인스턴스 초기화 블럭 | 생성자 |
| cv = 0 | cv = 1 | cv = 2 | cv = 2,
iv = 0 | cv = 2,
iv = 1 | cv = 2,
iv = 2 | cv = 2,
iv = 3 |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 |